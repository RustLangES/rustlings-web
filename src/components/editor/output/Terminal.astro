---
import IconLoader2 from "~icons/tabler/loader-2"
import IconPlayerPlay from "~icons/tabler/player-play"
import IconRestore from "~icons/tabler/restore"
import IconTerminal from "~icons/tabler/terminal"

interface Props {
	expectedOutput?: string
}

const { expectedOutput } = Astro.props
---

<terminal-output
	class="group h-full flex flex-col bg-dark-fg/60 border-t border-stroke-color text-sm font-mono rounded-b-2xl"
	data-expected={expectedOutput?.trim()}
>
	<header class="flex h-8 items-center gap-3 border-b border-stroke-color bg-light-bg px-3">
		<div class="flex items-center gap-2 text-secondary">
			<IconTerminal font-size={18} />
			<span class="font-medium">Output</span>
		</div>

		<div class="hidden flex-1 items-center rounded border border-gray-600 bg-dark-fg/40 px-2 py-0.5 group-data-running:flex">
			<span class="mr-2 text-green-400">â€º</span>
			<input
				id="stdin-input"
				type="text"
				class="w-full bg-transparent text-xs text-gray-300 outline-none"
				aria-label="Standard input"
			/>
		</div>

		<div class="flex-1 group-data-running:hidden"></div>

		<div class="flex gap-2 text-xs">
			<button
				id="btn-reset"
				class="btn-control hover:text-yellow"
				type="button"
				aria-label="Reset code"
			>
				<IconRestore font-size={14} />
				<span>Reiniciar</span>
			</button>

			<button
				id="btn-run"
				class="btn-control hover:text-green-500"
				type="button"
				aria-label="Run code"
			>
				<IconPlayerPlay class="group-data-running:hidden" font-size={14} />
				<IconLoader2 class="hidden animate-spin group-data-running:block" font-size={14} />
				<span class="group-data-running:hidden">Ejecutar</span>
				<span class="hidden group-data-running:inline">Ejecutando...</span>
			</button>
		</div>
	</header>

	<div id="console" class="flex-1 overflow-auto p-3" tabindex="0">
		<div class="mb-2 text-gray-400">
			<span class="text-green-400">$</span>
			<span class="text-yellow font-medium">cargo</span>
			<span>run</span>
		</div>
		<pre id="stderr" class="whitespace-pre text-sm empty:hidden"></pre>
		<hr id="separator" class="my-2 border-t border-gray-700 has-[~#stdout:empty]:hidden has-[+#stdout:empty]:hidden" />
		<pre id="stdout" class="whitespace-pre text-sm text-gray-300 empty:hidden"></pre>
	</div>
</terminal-output>

<script>
import { rustPlayground } from "~/lib/rust-playground";
import { db, editorCode } from "~/lib/stores/editor-store";
import { getStderrHTML } from "~/components/editor/output/renderer";

class TerminalOutput extends HTMLElement {
	private ui = {
		stdin: document.getElementById("stdin-input") as HTMLInputElement,
		console: document.getElementById("console") as HTMLDivElement,
		stderr: document.getElementById("stderr") as HTMLPreElement,
		stdout: document.getElementById("stdout") as HTMLPreElement,
		btnRun: document.getElementById("btn-run") as HTMLButtonElement,
		btnReset: document.getElementById("btn-reset") as HTMLButtonElement,
	};

	private state = {
		lastStderr: "",
		output: "",
	};

	connectedCallback() {
		this.ui.btnRun.addEventListener("click", this.execute);
		this.ui.btnReset.addEventListener("click", this.reset);
		this.ui.stdin.addEventListener("keydown", this.handleStdin);
	}

	private isScrolledToBottom(): boolean {
		const { scrollTop, scrollHeight, clientHeight } = this.ui.console;
		return scrollHeight - scrollTop - clientHeight < 5;
	}

	private handleStdin = (e: KeyboardEvent) => {
		if (e.key !== "Enter") return;

		e.preventDefault();
		const value = this.ui.stdin.value.trim();

		if (value) {
			rustPlayground.sendStdin(`${value}\n`);
			this.ui.stdin.value = "";
			this.scrollToBottom();
		}
	}

	private execute = () => {
		this.setRunning(true);
		this.clear();
		this.ui.stdin.focus();

		rustPlayground.execute(editorCode.get(), this.handleOutput, this.handleComplete);
	}

	private handleOutput = (stderr: string, stdout: string) => {
		const wasAtBottom = this.isScrolledToBottom();

		if (stderr && stderr !== this.state.lastStderr) {
			this.state.lastStderr = stderr;
			this.ui.stderr.innerHTML = getStderrHTML(stderr);
		}

		if (stdout) {
			this.state.output = stdout;
			this.ui.stdout.textContent = stdout;
		}

		if (wasAtBottom) {
			this.scrollToBottom();
		}
	}

	private handleComplete = async (success: boolean) => {
		this.setRunning(false);

		const slug = document.querySelector<HTMLElement>("[data-slug]")?.dataset.slug;
		const expected = this.dataset.expected?.trim();
		const actual = this.state.output.trim();
		const outputMatches = !expected || expected === actual;

		if (success && outputMatches && slug) {
			await db.markCompleted(slug);
			window.dispatchEvent(new CustomEvent("lesson:completed"));
		}

		if (success && expected && !outputMatches) {
			this.showMismatch(expected, actual);
		}
	}

	private showMismatch(expected: string, actual: string) {
		const mismatchDiv = document.createElement('div');
		mismatchDiv.innerHTML = `<hr class="border-t border-gray-700 my-2"><div><b><span class="text-red-400">error</span>: La salida no coincide con lo esperado</b></div><div>  Esperaba: <span class="text-green-400">${expected}</span></div>`;

		this.ui.stderr.innerHTML = getStderrHTML(this.state.lastStderr);
		this.ui.stderr.appendChild(mismatchDiv);
		this.scrollToBottom();
	}

	private reset = async () => {
		const editor = document.querySelector("[data-slug]") as HTMLElement;
		if (!editor) return;

		const { slug, initialCode } = editor.dataset;
		if (!slug || !initialCode) return;

		await db.reset(slug);
		editorCode.set(initialCode);
		window.dispatchEvent(new CustomEvent("editor:reset", { detail: { code: initialCode } }));
	}

	private setRunning(running: boolean) {
		this.toggleAttribute("data-running", running);
	}

	private clear() {
		this.ui.stderr.textContent = "";
		this.ui.stdout.textContent = "";
		this.state.lastStderr = "";
		this.state.output = "";
	}

	private scrollToBottom() {
		this.ui.console.scrollTop = this.ui.console.scrollHeight;
	}
}

customElements.define("terminal-output", TerminalOutput);
</script>
