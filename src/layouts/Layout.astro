---
import { ClientRouter } from "astro:transitions"
import "~/styles/global.css"
import favicon from "~/assets/images/webp/favicon.webp"

const {
	title = "RustLings Web",
	description = "Aprende Rust mediante ejercicios interactivos y desafíos. ¡Todo explicado aquí!",
} = Astro.props
---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>{title}</title>
    <link rel="icon" type="image/webp" href={favicon.src} />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <ClientRouter />
    <script>
      function processAdmonitions() {
        console.log("Processing admonitions...");
        const container = document.getElementById("content-markdown");
        if (!container) {
          console.error("Content container not found");
          return;
        }

        const blockquotes = container.querySelectorAll("blockquote");
        console.log(`Found ${blockquotes.length} blockquotes`);

        blockquotes.forEach((blockquote, index) => {
          const firstP = blockquote.querySelector("p:first-child");
          if (!firstP) {
            console.log(`Blockquote ${index}: No first paragraph found`);
            return;
          }

          // Check if there's a strong element with the marker
          const strong = firstP.querySelector("strong:first-of-type");
          if (strong) {
            const text = strong.textContent.trim();
            console.log(`Blockquote ${index}: Strong element text: "${text}"`);

            const admonitionMap = {
              "[!NOTE]": "admonition-note",
              "[!TIP]": "admonition-tip",
              "[!IMPORTANT]": "admonition-important",
              "[!WARNING]": "admonition-warning",
              "[!CAUTION]": "admonition-caution",
            };

            for (const [marker, className] of Object.entries(admonitionMap)) {
              if (text === marker) {
                blockquote.classList.add(className);
                strong.remove(); // Remove the marker element completely

                // Process line breaks in remaining content
                processLineBreaks(blockquote);

                console.log(`Blockquote ${index}: Applied ${className}`);
                break;
              }
            }
          } else {
            // Handle case where markdown doesn't wrap in strong
            const text = firstP.textContent.trim();
            console.log(
              `Blockquote ${index}: No strong element found, checking text: "${text}"`,
            );

            if (text.startsWith("[!")) {
              const admonitionMap = {
                "[!NOTE]": "admonition-note",
                "[!TIP]": "admonition-tip",
                "[!IMPORTANT]": "admonition-important",
                "[!WARNING]": "admonition-warning",
                "[!CAUTION]": "admonition-caution",
              };

              for (const [marker, className] of Object.entries(admonitionMap)) {
                if (text.startsWith(marker)) {
                  blockquote.classList.add(className);

                  // Remove just the marker from the beginning of the text
                  const remainingText = text.substring(marker.length).trim();
                  if (remainingText.length > 0) {
                    // If there's remaining text, update the paragraph
                    firstP.textContent = remainingText;
                  } else {
                    // If the first paragraph only contained the marker, remove it
                    firstP.remove();
                  }

                  // Process line breaks in remaining content
                  processLineBreaks(blockquote);

                  console.log(
                    `Blockquote ${index}: Applied ${className} (direct text match)`,
                  );
                  break;
                }
              }
            }
          }
        });
      }

      function processLineBreaks(blockquote) {
        // Convert text content to have proper line breaks
        const paragraphs = blockquote.querySelectorAll("p");
        paragraphs.forEach((p) => {
          // Replace sequences of spaces with line breaks to simulate the original > lines
          const text = p.textContent;
          if (text.includes("  ")) {
            // Split on double spaces (markdown line break pattern) and create line breaks
            const lines = text.split(/\s{2,}/).filter((line) => line.trim());
            if (lines.length > 1) {
              p.innerHTML = lines.join("<br>");
            }
          }
        });
      }

      // Try multiple timing strategies
      document.addEventListener("DOMContentLoaded", processAdmonitions);

      // Also try after astro transitions
      document.addEventListener("astro:page-load", processAdmonitions);

      // Fallback with timeout
      setTimeout(processAdmonitions, 100);
    </script>
  </head>
  <body
    class="h-screen flex flex-col bg-primary text-secondary font-family-poppins"
  >
    <slot />
  </body>
</html>
