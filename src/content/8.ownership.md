---
nextPath: "borrowing"
previousPath: "estructuras-control"
editor: true
order: 8
---

# Ownership: El Coraz칩n de Rust

El sistema de ownership (propiedad) es la caracter칤stica m치s distintiva de Rust y lo que permite garantizar seguridad de memoria sin un recolector de basura. Entender ownership es fundamental para programar efectivamente en Rust.

## 쯈u칠 es Ownership?

Ownership es un sistema que gestiona la memoria autom치ticamente siguiendo un conjunto de reglas que el compilador verifica en tiempo de compilaci칩n. Si cualquiera de estas reglas se viola, el programa no compilar치.

### Las Tres Reglas de Ownership

1. **Cada valor en Rust tiene un 칰nico propietario**
2. **Solo puede haber un propietario a la vez**
3. **Cuando el propietario sale del scope, el valor se elimina**

## Scope (츼mbito)

Un scope es el rango dentro del programa donde una variable es v치lida:

```rust
fn main() {
    // s no est치 disponible aqu칤, no ha sido declarada a칰n
    
    {
        let s = "hola"; // s es v치lida desde este punto
        
        // hacer cosas con s
        println!("{s}");
    } // este scope termina, s ya no es v치lida
    
    // println!("{s}"); // ERROR: s no est치 en scope
}
```

## Tipos de Datos y Memoria

### Stack vs Heap

```rust
fn main() {
    // Datos en el stack (tama침o conocido, fijo)
    let x = 5;        // i32 en stack
    let y = x;        // se copia el valor
    
    println!("x: {x}, y: {y}"); // Ambos son v치lidos
    
    // Datos en el heap (tama침o variable)
    let s1 = String::from("hola"); // String en heap
    let s2 = s1;                   // se mueve la propiedad
    
    // println!("{s1}"); // ERROR: s1 ya no es v치lido
    println!("{s2}");    // Solo s2 es v치lido
}
```

### Tipos Copy vs Move

```rust
fn main() {
    // Tipos que implementan Copy (se duplican autom치ticamente)
    let x = 5;
    let y = x; // x se copia
    println!("x: {x}, y: {y}"); // Ambos funcionan
    
    // Tipos que no implementan Copy (se mueven)
    let s1 = String::from("mundo");
    let s2 = s1; // s1 se mueve a s2
    // println!("{s1}"); // ERROR: value borrowed here after move
    
    // Para duplicar, usa clone()
    let s3 = String::from("rust");
    let s4 = s3.clone(); // Copia profunda
    println!("s3: {s3}, s4: {s4}"); // Ambos funcionan
}
```

### Tipos que Implementan Copy

```rust
fn main() {
    // Tipos escalares
    let a = 5;          // i32
    let b = true;       // bool  
    let c = 'R';        // char
    let d = 3.14;       // f64
    
    // Tuplas de tipos Copy
    let punto = (3, 4); // (i32, i32)
    let otro_punto = punto; // Se copia
    
    println!("Original: {:?}", punto);
    println!("Copia: {:?}", otro_punto);
    
    // Arrays de tipos Copy
    let array = [1, 2, 3, 4, 5];
    let otro_array = array; // Se copia
    
    println!("Original: {:?}", array);
    println!("Copia: {:?}", otro_array);
}
```

## Ownership y Funciones

### Pasar Valores a Funciones

```rust
fn main() {
    let s = String::from("hola");    // s entra en scope
    
    tomar_ownership(s);              // s se mueve a la funci칩n
                                     // s ya no es v치lido aqu칤
    
    // println!("{s}"); // ERROR: value borrowed here after move
    
    let x = 5;                       // x entra en scope
    
    hacer_copia(x);                  // x se copia a la funci칩n
                                     // x sigue siendo v치lido
    println!("x sigue siendo: {x}"); // Esto funciona
    
} // x sale de scope, pero s ya hab칤a salido cuando se movi칩

fn tomar_ownership(texto: String) { // texto entra en scope
    println!("{texto}");
} // texto sale de scope y se elimina

fn hacer_copia(entero: i32) { // entero entra en scope
    println!("{entero}");
} // entero sale de scope, pero no pasa nada especial
```

### Retornar Valores desde Funciones

```rust
fn main() {
    let s1 = dar_ownership();           // funci칩n mueve su valor de retorno a s1
    
    let s2 = String::from("hola");      // s2 entra en scope
    
    let s3 = tomar_y_dar_ownership(s2); // s2 se mueve a la funci칩n,
                                        // que mueve su valor de retorno a s3
    
    println!("s1: {s1}");
    // println!("{s2}"); // ERROR: s2 ya no es v치lido
    println!("s3: {s3}");
    
} // s3 sale de scope y se elimina
  // s1 sale de scope y se elimina  
  // s2 ya hab칤a salido de scope, no pasa nada

fn dar_ownership() -> String {              // funci칩n mueve su valor de retorno
    let texto = String::from("tuyo");      // texto entra en scope
    texto                                   // texto se retorna y sale de scope
}

fn tomar_y_dar_ownership(texto: String) -> String { // texto entra en scope
    texto  // texto se retorna y sale de scope
}
```

## Patrones Comunes con Ownership

### Retornar M칰ltiples Valores

```rust
fn main() {
    let s1 = String::from("hola");
    
    let (s2, longitud) = calcular_longitud(s1);
    
    println!("La longitud de '{s2}' es {longitud}.");
}

fn calcular_longitud(s: String) -> (String, usize) {
    let longitud = s.len(); // len() retorna la longitud de un String
    
    (s, longitud) // Retornamos tanto el String como su longitud
}
```

### Clonar para Mantener Ownership

```rust
fn main() {
    let s1 = String::from("hola mundo");
    
    // Clonar antes de pasar a la funci칩n
    let longitud = calcular_longitud_clonando(s1.clone());
    
    println!("'{s1}' tiene {longitud} caracteres");
    
    // Tambi칠n podemos usar to_owned()
    let palabras = contar_palabras(s1.to_owned());
    println!("'{s1}' tiene {palabras} palabras");
}

fn calcular_longitud_clonando(s: String) -> usize {
    s.len()
} // s sale de scope y se elimina (es una copia)

fn contar_palabras(s: String) -> usize {
    s.split_whitespace().count()
} // s sale de scope y se elimina
```

## Ownership con Colecciones

### Vectores y Ownership

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    
    // Tomar ownership del vector
    let v2 = v; // v se mueve a v2
    // println!("{:?}", v); // ERROR: value borrowed here after move
    
    // Crear nuevo vector
    let mut numeros = vec![10, 20, 30];
    
    // Procesar sin mover
    procesar_vector(numeros.clone());
    println!("Original a칰n disponible: {:?}", numeros);
    
    // Mover definitivamente
    let resultado = tomar_vector(numeros);
    println!("Resultado: {:?}", resultado);
    // println!("{:?}", numeros); // ERROR: moved
}

fn procesar_vector(v: Vec<i32>) {
    println!("Procesando: {:?}", v);
} // v se elimina aqu칤

fn tomar_vector(mut v: Vec<i32>) -> Vec<i32> {
    v.push(40);
    v
} // Retorna el vector modificado
```

### HashMap y Ownership

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    
    // Tipos Copy se insertan sin problema
    scores.insert(String::from("Azul"), 10);
    scores.insert(String::from("Amarillo"), 50);
    
    // Los String se mueven al HashMap
    let field_name = String::from("Favorito");
    let field_value = String::from("Azul");
    
    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name y field_value ya no son v치lidos
    
    // Para mantener ownership, clona antes de insertar
    let key = String::from("nuevo");
    let value = String::from("valor");
    
    map.insert(key.clone(), value.clone());
    println!("Key: {key}, Value: {value}"); // A칰n disponibles
    
    println!("Mapa: {:?}", map);
}
```

## Drop y RAII

El trait `Drop` permite personalizar qu칠 ocurre cuando un valor sale de scope:

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Eliminando CustomSmartPointer con data '{}'!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("mi dato"),
    };
    
    let d = CustomSmartPointer {
        data: String::from("otro dato"),
    };
    
    println!("CustomSmartPointers creados.");
    
    // Eliminar manualmente con drop()
    drop(c); // Equivale a std::mem::drop(c)
    println!("CustomSmartPointer eliminado antes del final de scope");
    
} // d se elimina autom치ticamente aqu칤
```

## Ejercicios Pr치cticos

### Ejercicio 1: Gesti칩n de Strings

```rust
fn main() {
    // Crear un string
    let mensaje = crear_mensaje("Hola".to_string(), "Rust".to_string());
    println!("Mensaje: {mensaje}");
    
    // Procesar sin perder ownership
    let (procesado, longitud) = procesar_mensaje(mensaje);
    println!("Procesado: {procesado} (longitud: {longitud})");
    
    // Usar el string procesado
    mostrar_mensaje(procesado);
}

fn crear_mensaje(saludo: String, nombre: String) -> String {
    format!("{saludo}, {nombre}!")
}

fn procesar_mensaje(mut msg: String) -> (String, usize) {
    msg.push_str(" 游");
    let len = msg.len();
    (msg, len)
}

fn mostrar_mensaje(msg: String) {
    println!("Mostrando: {msg}");
} // msg se elimina aqu칤
```

### Ejercicio 2: Lista de Tareas

```rust
fn main() {
    let mut tareas = vec![
        String::from("Aprender Rust"),
        String::from("Hacer ejercicios"),
        String::from("Construir un proyecto"),
    ];
    
    println!("Tareas originales:");
    mostrar_tareas(tareas.clone()); // Clonar para mantener ownership
    
    // Agregar nueva tarea
    tareas = agregar_tarea(tareas, String::from("Compartir conocimiento"));
    
    println!("\nDespu칠s de agregar:");
    mostrar_tareas(tareas.clone());
    
    // Completar primera tarea
    let (tareas_restantes, completada) = completar_primera_tarea(tareas);
    println!("\nTarea completada: {completada}");
    
    println!("Tareas restantes:");
    mostrar_tareas(tareas_restantes);
}

fn mostrar_tareas(tareas: Vec<String>) {
    for (i, tarea) in tareas.iter().enumerate() {
        println!("  {}. {}", i + 1, tarea);
    }
}

fn agregar_tarea(mut tareas: Vec<String>, nueva_tarea: String) -> Vec<String> {
    tareas.push(nueva_tarea);
    tareas
}

fn completar_primera_tarea(mut tareas: Vec<String>) -> (Vec<String>, String) {
    let completada = tareas.remove(0);
    (tareas, completada)
}
```

### Ejercicio 3: Contador con Ownership

```rust
fn main() {
    let contador = crear_contador(0);
    println!("Contador inicial: {contador}");
    
    let contador = incrementar(contador, 5);
    println!("Despu칠s de incrementar 5: {contador}");
    
    let contador = decrementar(contador, 2);
    println!("Despu칠s de decrementar 2: {contador}");
    
    let (contador, es_par) = verificar_paridad(contador);
    println!("Contador: {contador}, 쮼s par? {es_par}");
}

fn crear_contador(inicial: i32) -> i32 {
    inicial
}

fn incrementar(contador: i32, cantidad: i32) -> i32 {
    contador + cantidad
}

fn decrementar(contador: i32, cantidad: i32) -> i32 {
    contador - cantidad
}

fn verificar_paridad(contador: i32) -> (i32, bool) {
    (contador, contador % 2 == 0)
}
```

## Errores Comunes con Ownership

### Error 1: Usar despu칠s de Mover

```rust
fn main() {
    let s1 = String::from("hola");
    let s2 = s1; // s1 se mueve a s2
    
    // println!("{s1}"); // ERROR: borrow of moved value
    
    // Soluci칩n: clonar
    let s3 = String::from("mundo");
    let s4 = s3.clone();
    println!("{s3} {s4}"); // Ambos funcionan
}
```

### Error 2: Retornar Referencias Locales

```rust
// 춰ESTO NO COMPILA!
// fn crear_string() -> &String {
//     let s = String::from("hola");
//     &s // ERROR: returns a reference to data owned by the current function
// }

// Soluci칩n: retornar el valor, no una referencia
fn crear_string() -> String {
    String::from("hola") // Transfiere ownership
}

fn main() {
    let s = crear_string();
    println!("{s}");
}
```

## Puntos Clave para Recordar

1. **Cada valor tiene un 칰nico propietario** en cualquier momento
2. **Mover transfiere ownership**, el valor original ya no es accesible  
3. **Clonar crea una copia independiente** pero es m치s costoso
4. **Los tipos Copy se duplican autom치ticamente** (enteros, bool, char, etc.)
5. **Las funciones pueden tomar y retornar ownership**
6. **Usar `drop()` para eliminar valores manualmente**
7. **RAII: los recursos se liberan autom치ticamente** al salir de scope
8. **El compilador previene use-after-free** y double-free autom치ticamente

## Pr칩ximo Paso

El ownership puede ser restrictivo cuando solo quieres "prestar" un valor temporalmente. En el siguiente cap칤tulo aprenderemos sobre **Borrowing** y **Referencias**, que nos permiten usar valores sin tomar su ownership.