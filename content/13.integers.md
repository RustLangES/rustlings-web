---
nextPath: ""
previousPath: "slice-string"
initialCode: |
    fn main() {
        let entero_negativo
        let entero_positivo
        let entero_mil 

        let suma = entero_negativo + entero_positivo + entero_mil;
        let multiplicacion = entero_negativo * entero_positivo * entero_mil;

        // No modificar esto üëÄ
        println!("Suma: {suma}");
        println!("Multiplicaci√≥n: {multiplicacion}");
    }
tests:
    - "code should be contain `i8`"
    - "code should be contain `u16`"
    - "code should be contain `i32`"
    - "code should be contain `Suma: `"
    - "code should be contain `Multiplicaci√≥n: `"
order: 13
---

# Tipos de datos: Enteros

En Rust, adem√°s de los booleanos, flotantes, caracteres (`char`) y los slices (`&str`), tenemos otros tipos **escalares**.
Los escalares representan un √∫nico valor simple, no una colecci√≥n.
Los m√°s comunes son: **enteros, flotantes, booleanos y caracteres**.

## üîπ Enteros

Los enteros son n√∫meros sin parte decimal.
En Rust existen varios tama√±os, tanto **con signo** (`i`) como **sin signo** (`u`):

* `i8`, `i16`, `i32`, `i64`, `i128`, `isize` ‚Üí con signo (pueden ser negativos).
* `u8`, `u16`, `u32`, `u64`, `u128`, `usize` ‚Üí sin signo (solo positivos).

üëâ El n√∫mero indica la **cantidad de bits** que ocupa en memoria.
Por ejemplo:

* `i8` ‚Üí son numeros en el rango de -128 a 127.
* `u8` ‚Üí son numeros en el rango de 0 a 255.
* `i32` ‚Üí son numeros en el rango de -2,147,483,648 a 2,147,483,647.

---

## Ejemplo b√°sico

```rust
fn main() {
    let positivo: u32 = 42;
    let negativo: i32 = -42;

    println!("N√∫mero positivo: {positivo}");
    println!("N√∫mero negativo: {negativo}");
}
```

Salida:

```sh [salida]
N√∫mero positivo: 42
N√∫mero negativo: -42
```

---

## üîπ Operaciones con enteros

Podemos realizar operaciones aritm√©ticas b√°sicas:

```rust
fn main() {
    let a: i32 = 10;
    let b: i32 = 3;

    println!("Suma: {}", a + b);
    println!("Resta: {}", a - b);
    println!("Multiplicaci√≥n: {}", a * b);
    println!("Divisi√≥n: {}", a / b);
    println!("M√≥dulo: {}", a % b);
}
```

---

## üîπ Literales de enteros

Rust permite escribir enteros en distintos formatos:

```rust
fn main() {
    let decimal = 98_222;     // decimal (los _ son separadores)
    let hexadecimal = 0xff;   // hexadecimal
    let octal = 0o77;         // octal
    let binario = 0b1111_0000; // binario
    let byte = b'A';          // byte (u8 con valor ASCII)

    println!("{decimal}, {hexadecimal}, {octal}, {binario}, {byte}");
}
```

Los cuales no suelen ser formatos tipicos pero estan disponibles.

La manera m√°s sencilla de declarar un entero es sin especificar el tipo, en cuyo caso Rust asume que es `i32`:

```rust
fn main() {
    let numero = 42; // Asumido como i32 por defecto
    println!("N√∫mero: {numero}");
}
```

Salida:

```sh [salida]
N√∫mero: 42
```

Es la forma m√°s t√≠pica.

---

## üîπ Recapitulemos

* Los **enteros** son valores escalares que representan n√∫meros sin decimales.
* Existen tipos con signo (`iXX`) y sin signo (`uXX`).
* Podemos hacer operaciones aritm√©ticas b√°sicas (`+`, `-`, `*`, `/`, `%`).
* Tambi√©n existen literales en distintas bases: decimal, hex, octal, binario y byte.

---

## ‚úçÔ∏è Ejercicio

1. Declara tres variables de tipo entero:

   * Una de tipo `i8` con un n√∫mero negativo.
   * Una de tipo `u16` con un n√∫mero positivo.
   * Una de tipo `i32` con el valor `1000`.
2. Realiza una suma y una multiplicaci√≥n usando esas variables.
3. üëâ No cambies los `println!` ya escritos.
4. ¬°Ejecuta el c√≥digo y revisa el resultado!

