---
nextPath: "bool-and-float"
previousPath: "constants"
expectedResponse: "El valor final es: 15\n"
initialCode: |
  fn main() {
    // Crea la variable valor con el string "10"

    // Asigna el parseo a un entero usando shadowing a la variable valor
    
    valor.parse::<i32>().expect("No es un n√∫mero");

    // Suma 5 al valor

    // Muestra el resultado
    println!("El valor final es: {valor}");
  }
order: 9
---

# Shadowing

En Rust, cuando declaramos una variable con `let`, su nombre queda asociado a un valor en memoria.
El **shadowing** ocurre cuando volvemos a declarar una variable con el mismo nombre que otra anterior, usando nuevamente `let`. Esto *sombrea* (shadow) la variable anterior, es decir, la nueva declaraci√≥n la reemplaza en el alcance actual.

Lo importante es que, a diferencia de hacer la variable `mut`, el shadowing nos permite:

* **Cambiar el valor** asociado a la variable.
* **Cambiar el tipo** de la variable.

Ejemplo:

```rust
fn main() {
    let x = 5;       // x es un n√∫mero entero
    let x = x + 1;   // x ahora vale 6
    let x = "texto"; // x ahora es un string, diferente tipo
    println!("{x}");
}
```

En este caso, la variable `x` cambia tanto de valor como de tipo, algo que no ser√≠a posible con `mut`. Esto lo hace muy √∫til para transformar datos paso a paso sin necesidad de inventar nuevos nombres de variables.

---

### üìù Ejercicio

Crea un programa que:

1. Defina una variable llamada `valor` con el n√∫mero `10`.
2. Use **shadowing** para:
    * Parsear `valor` a un entero.
        * Para esto usaremos el m√©todo `parse::<i32>()` que convierte un string a un entero de 32 bits.
        * Como `parse` puede fallar, usaremos `expect("No es un n√∫mero")` para manejar el caso de error.
3. Luego **suma** `5` al valor.
4. Imprime el resultado final.

