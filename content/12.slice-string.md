---
nextPath: ""
previousPath: "characters"
initialCode: |
    fn main() {
        let texto = "Ejercitando en Rustlings Web";

        let slice1 = 
        let slice2 =

        println!("{slice1}");
        println!("{slice2}");
    }
expectedResponse: "Ejercitando\nRust\n"
order: 12
---

# Tipos de datos: Slices de cadena (`&str`)

En Rust, adem치s de los caracteres (`char`), existe una forma muy com칰n de representar texto: el **slice de cadena** o `&str`.

---

## 游댳 쯈u칠 es un `&str`?

Un `&str` es una **vista inmutable sobre una cadena de texto**.

* Se suele usar para literales de cadena (`"hola"`).
* No lo podemos modificar.
* Se guarda como una **referencia** a una secuencia de bytes UTF-8.

游녤 Piensa en `&str` como un "texto prestado": est치 ah칤, puedes leerlo, pero no puedes cambiarlo.

---

## Ejemplo b치sico

```rust
fn main() {
    let saludo: &str = "Hola mundo";

    println!("Saludo: {saludo}");
}
```

Salida:

```sh [salida]
Saludo: Hola mundo
```

Tambi칠n podemos crear slices a partir de otros `&str`:

```rust
fn main() {
    let texto: &str = "Aprendiendo Rust";
    let slice1: &str = &texto[0..11]; // "Aprendiendo"
    let slice2: &str = &texto[12..16]; // "Rust"

    println!("Slice 1: {slice1}");
    println!("Slice 2: {slice2}");
}
```

Salida:

```sh [salida]
Slice 1: Aprendiendo
Slice 2: Rust
```

---

## 游댳 Recapitulemos

* `&str` representa una **cadena inmutable**, com칰nmente usada para literales (`"hola"`).
* Es el tipo m치s **ligero y eficiente** para representar cadenas de texto, ya que no necesita asignar memoria din치mica.
* Podemos obtener `&str` a partir de:

  * Un literal (`"texto"`).
  * Un slice de otro `&str` (`texto[0..4]`).

游녤 En cap칤tulos posteriores veremos c칩mo combinar `&str` y `String` para trabajar con texto mutable y prestado al mismo tiempo.

---

## 九꽲잺 Ejercicio

1. Declara un `&str` con el valor `"Ejercitando en Rustlings Web"`.
2. Crea un slice con la palabra `"Ejercitando"`.
3. Crea otro slice con la palabra `"Rust"`.
4. Imprime ambos slices con `println!`.
5. 游녤 No modifiques los `println!` que ya est치n en el c칩digo base.