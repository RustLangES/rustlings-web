---
nextPath: ""
previousPath: "characters"
initialCode: |
    fn main() {
        let texto = "Ejercitando en Rustlings Web";

        let slice1 = 
        let slice2 =

        println!("{slice1}");
        println!("{slice2}");
    }
expectedResponse: "Ejercitando\nRust\n"
order: 12
---

# Tipos de datos: Slices de cadena (`&str`)

En Rust, además de los caracteres (`char`), existe una forma muy común de representar texto: el **slice de cadena** o `&str`.

---

## 🔹 ¿Qué es un `&str`?

Un `&str` es una **vista inmutable sobre una cadena de texto**.

* Se suele usar para literales de cadena (`"hola"`).
* No lo podemos modificar.
* Se guarda como una **referencia** a una secuencia de bytes UTF-8.

👉 Piensa en `&str` como un "texto prestado": está ahí, puedes leerlo, pero no puedes cambiarlo.

---

## Ejemplo básico

```rust
fn main() {
    let saludo: &str = "Hola mundo";

    println!("Saludo: {saludo}");
}
```

Salida:

```sh [salida]
Saludo: Hola mundo
```

También podemos crear slices a partir de otros `&str`:

```rust
fn main() {
    let texto: &str = "Aprendiendo Rust";
    let slice1: &str = &texto[0..11]; // "Aprendiendo"
    let slice2: &str = &texto[12..16]; // "Rust"

    println!("Slice 1: {slice1}");
    println!("Slice 2: {slice2}");
}
```

Salida:

```sh [salida]
Slice 1: Aprendiendo
Slice 2: Rust
```

---

## 🔹 Recapitulemos

* `&str` representa una **cadena inmutable**, comúnmente usada para literales (`"hola"`).
* Es el tipo más **ligero y eficiente** para representar cadenas de texto, ya que no necesita asignar memoria dinámica.
* Podemos obtener `&str` a partir de:

  * Un literal (`"texto"`).
  * Un slice de otro `&str` (`texto[0..4]`).

👉 En capítulos posteriores veremos cómo combinar `&str` y `String` para trabajar con texto mutable y prestado al mismo tiempo.

---

## ✍️ Ejercicio

1. Declara un `&str` con el valor `"Ejercitando en Rustlings Web"`.
2. Crea un slice con la palabra `"Ejercitando"`.
3. Crea otro slice con la palabra `"Rust"`.
4. Imprime ambos slices con `println!`.
5. 👉 No modifiques los `println!` que ya están en el código base.