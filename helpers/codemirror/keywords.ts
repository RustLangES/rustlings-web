import type { Completion } from "@codemirror/autocomplete";

const rustKeywords: Completion[] = [
  { label: "as", type: "keyword", info: "Realiza conversiones de tipos explícitas" },
  { label: "async", type: "keyword", info: "Habilita funciones y bloques asíncronos" },
  { label: "await", type: "keyword", info: "Espera el resultado de una operación asíncrona" },
  { label: "box", type: "keyword", info: "Palabra clave reservada para asignación dinámica" },
  { label: "break", type: "keyword", info: "Rompe un bucle" },
  { label: "const", type: "keyword", info: "Declara una constante inmutable en tiempo de compilación" },
  { label: "continue", type: "keyword", info: "Continúa con la siguiente iteración de un bucle" },
  { label: "crate", type: "keyword", info: "Referencia al crate actual" },
  { label: "dyn", type: "keyword", info: "Indica un trait dinámico en un puntero o referencia" },
  { label: "else", type: "keyword", info: "Rama alternativa de un condicional" },
  { label: "enum", type: "keyword", info: "Declara una enumeración" },
  { label: "extern", type: "keyword", info: "Declara una función o bloque con enlace externo" },
  { label: "false", type: "keyword", info: "Valor booleano falso" },
  { label: "fn", type: "keyword", info: "Define una función" },
  { label: "for", type: "keyword", info: "Bucle for" },
  { label: "if", type: "keyword", info: "Condicional" },
  { label: "impl", type: "keyword", info: "Implementa una estructura o trait" },
  { label: "in", type: "keyword", info: "Itera sobre elementos en bucles for" },
  { label: "let", type: "keyword", info: "Declara una variable" },
  { label: "loop", type: "keyword", info: "Bucle infinito" },
  { label: "match", type: "keyword", info: "Patrón de coincidencia" },
  { label: "mod", type: "keyword", info: "Declara un módulo" },
  { label: "move", type: "keyword", info: "Indica que el cierre captura variables por valor" },
  { label: "mut", type: "keyword", info: "Marca una variable como mutable" },
  { label: "pub", type: "keyword", info: "Marca un elemento como público" },
  { label: "ref", type: "keyword", info: "Crea una referencia en un patrón de coincidencia" },
  { label: "return", type: "keyword", info: "Devuelve un valor de una función" },
  { label: "self", type: "keyword", info: "Referencia a la instancia actual" },
  { label: "static", type: "keyword", info: "Declara una variable estática de duración estática" },
  { label: "struct", type: "keyword", info: "Declara una estructura" },
  { label: "super", type: "keyword", info: "Referencia al módulo superior" },
  { label: "trait", type: "keyword", info: "Declara un trait" },
  { label: "true", type: "keyword", info: "Valor booleano verdadero" },
  { label: "type", type: "keyword", info: "Declara un alias de tipo" },
  { label: "unsafe", type: "keyword", info: "Declara bloques o funciones no seguras" },
  { label: "use", type: "keyword", info: "Importa módulos o elementos" },
  { label: "where", type: "keyword", info: "Establece restricciones en los parámetros de tipo" },
  { label: "while", type: "keyword", info: "Bucle while" },
  { label: "default", type: "keyword", info: "Proporciona una implementación predeterminada en traits" },
  { label: "union", type: "keyword", info: "Declara una unión de tipos" },
  //{ label: "try", type: "keyword", info: "Usado en bloques `catch` (experimental)" },
  //{ label: "catch", type: "keyword", info: "Maneja excepciones (experimental)" },
  //{ label: "abstract", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "alignof", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "become", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "do", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "final", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "macro", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "offsetof", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "override", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "priv", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "proc", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "pure", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "sizeof", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "typeof", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "unsized", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "virtual", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" },
  //{ label: "yield", type: "keyword", info: "Palabra clave reservada (no utilizada actualmente)" }
];

const rustTypeKeywords: Completion[] = [
  { label: "Self", type: "type", info: "Referencia al tipo de la instancia actual" },
  { label: "int", type: "type", info: "Tipo entero genérico (obsoleto)" },
  { label: "uint", type: "type", info: "Tipo entero sin signo genérico (obsoleto)" },
  { label: "float", type: "type", info: "Tipo de punto flotante genérico (obsoleto)" },
  { label: "char", type: "type", info: "Tipo de carácter Unicode" },
  { label: "bool", type: "type", info: "Tipo booleano" },
  { label: "u8", type: "type", info: "Tipo entero sin signo de 8 bits" },
  { label: "u16", type: "type", info: "Tipo entero sin signo de 16 bits" },
  { label: "u32", type: "type", info: "Tipo entero sin signo de 32 bits" },
  { label: "u64", type: "type", info: "Tipo entero sin signo de 64 bits" },
  { label: "f32", type: "type", info: "Tipo de punto flotante de 32 bits" },
  { label: "f64", type: "type", info: "Tipo de punto flotante de 64 bits" },
  { label: "i8", type: "type", info: "Tipo entero con signo de 8 bits" },
  { label: "i16", type: "type", info: "Tipo entero con signo de 16 bits" },
  { label: "i32", type: "type", info: "Tipo entero con signo de 32 bits" },
  { label: "i64", type: "type", info: "Tipo entero con signo de 64 bits" },
  { label: "str", type: "type", info: "Tipo de cadena de texto inmutable" },
  { label: "Option", type: "type", info: "Tipo de opción para valores opcionales" },
  { label: "Either", type: "type", info: "Tipo para valores que pueden ser de dos tipos distintos" },
  { label: "c_float", type: "type", info: "Tipo flotante compatible con C" },
  { label: "c_double", type: "type", info: "Tipo de doble precisión compatible con C" },
  { label: "c_void", type: "type", info: "Tipo vacío compatible con C" },
  { label: "FILE", type: "type", info: "Tipo de archivo de C" },
  { label: "fpos_t", type: "type", info: "Tipo de posición de archivo en C" },
  { label: "DIR", type: "type", info: "Tipo de directorio de C" },
  { label: "dirent", type: "type", info: "Tipo de entrada de directorio en C" },
  { label: "c_char", type: "type", info: "Tipo de carácter compatible con C" },
  { label: "c_schar", type: "type", info: "Tipo de carácter con signo compatible con C" },
  { label: "c_uchar", type: "type", info: "Tipo de carácter sin signo compatible con C" },
  { label: "c_short", type: "type", info: "Tipo de entero corto compatible con C" },
  { label: "c_ushort", type: "type", info: "Tipo de entero corto sin signo compatible con C" },
  { label: "c_int", type: "type", info: "Tipo de entero compatible con C" },
  { label: "c_uint", type: "type", info: "Tipo de entero sin signo compatible con C" },
  { label: "c_long", type: "type", info: "Tipo de entero largo compatible con C" },
  { label: "c_ulong", type: "type", info: "Tipo de entero largo sin signo compatible con C" },
  { label: "size_t", type: "type", info: "Tipo de tamaño de datos en C" },
  { label: "ptrdiff_t", type: "type", info: "Tipo de diferencia de punteros en C" },
  { label: "clock_t", type: "type", info: "Tipo de reloj en C" },
  { label: "time_t", type: "type", info: "Tipo de tiempo en C" },
  { label: "c_longlong", type: "type", info: "Tipo de entero largo largo compatible con C" },
  { label: "c_ulonglong", type: "type", info: "Tipo de entero largo largo sin signo compatible con C" },
  { label: "intptr_t", type: "type", info: "Tipo entero que puede contener un puntero" },
  { label: "uintptr_t", type: "type", info: "Tipo entero sin signo que puede contener un puntero" },
  { label: "off_t", type: "type", info: "Tipo de desplazamiento en C" },
  { label: "dev_t", type: "type", info: "Tipo de dispositivo en C" },
  { label: "ino_t", type: "type", info: "Tipo de número de inodo en C" },
  { label: "pid_t", type: "type", info: "Tipo de identificador de proceso en C" },
  { label: "mode_t", type: "type", info: "Tipo de modo en C" },
  { label: "ssize_t", type: "type", info: "Tipo de tamaño con signo en C" }
  //{ label: "m32", type: "type", info: "Tipo SIMD de 32 bits (experimental)" },
  //{ label: "m64", type: "type", info: "Tipo SIMD de 64 bits (experimental)" },
  //{ label: "m128", type: "type", info: "Tipo SIMD de 128 bits (experimental)" },
  //{ label: "f80", type: "type", info: "Tipo de punto flotante de 80 bits (experimental)" },
  //{ label: "f16", type: "type", info: "Tipo de punto flotante de 16 bits (experimental)" },
  //{ label: "f128", type: "type", info: "Tipo de punto flotante de 128 bits (experimental)" },
];

const rustConstants: Completion[] = [
  { label: "true", type: "constant", info: "Valor booleano verdadero" },
  { label: "false", type: "constant", info: "Valor booleano falso" },
  { label: "Some", type: "constant", info: "Envuelve un valor en una opción" },
  { label: "None", type: "constant", info: "Representa la ausencia de un valor en una opción" },
  { label: "Ok", type: "constant", info: "Representa un resultado exitoso" },
  { label: "Err", type: "constant", info: "Representa un resultado con error" }
  //{ label: "Left", type: "constant", info: "Representa el valor izquierdo de un Either" },
  //{ label: "Right", type: "constant", info: "Representa el valor derecho de un Either" },
];

const rustSupportConstants: Completion[] = [
  { label: "EXIT_FAILURE", type: "constant", info: "Código de salida para fallo en un programa" },
  { label: "EXIT_SUCCESS", type: "constant", info: "Código de salida para éxito en un programa" },
  { label: "RAND_MAX", type: "constant", info: "Valor máximo para la función rand" },
  { label: "EOF", type: "constant", info: "Marca de fin de archivo en operaciones de lectura" },
  { label: "SEEK_SET", type: "constant", info: "Inicio del archivo en operaciones de seek" },
  { label: "SEEK_CUR", type: "constant", info: "Posición actual en operaciones de seek" },
  { label: "SEEK_END", type: "constant", info: "Final del archivo en operaciones de seek" },
  { label: "_IOFBF", type: "constant", info: "Modo de buffer completo en operaciones de I/O" },
  { label: "_IONBF", type: "constant", info: "Modo sin buffer en operaciones de I/O" },
  { label: "_IOLBF", type: "constant", info: "Modo de buffer por línea en operaciones de I/O" },
  { label: "BUFSIZ", type: "constant", info: "Tamaño predeterminado de buffer en C" },
  { label: "FOPEN_MAX", type: "constant", info: "Número máximo de archivos que se pueden abrir" },
  { label: "FILENAME_MAX", type: "constant", info: "Longitud máxima de un nombre de archivo" },
  { label: "L_tmpnam", type: "constant", info: "Longitud máxima para nombres temporales de archivo" },
  { label: "TMP_MAX", type: "constant", info: "Número máximo de nombres temporales únicos" },
  { label: "O_RDONLY", type: "constant", info: "Abrir un archivo solo para lectura" },
  { label: "O_WRONLY", type: "constant", info: "Abrir un archivo solo para escritura" },
  { label: "O_RDWR", type: "constant", info: "Abrir un archivo para lectura y escritura" },
  { label: "O_APPEND", type: "constant", info: "Escribir siempre al final del archivo" },
  { label: "O_CREAT", type: "constant", info: "Crear un archivo si no existe" },
  { label: "O_EXCL", type: "constant", info: "Crear un archivo solo si no existe" },
  { label: "O_TRUNC", type: "constant", info: "Truncar el archivo al abrirlo" },
  { label: "S_IFIFO", type: "constant", info: "Tipo de archivo FIFO o canal" },
  { label: "S_IFCHR", type: "constant", info: "Tipo de archivo de carácter especial" },
  { label: "S_IFBLK", type: "constant", info: "Tipo de archivo de bloque especial" },
  { label: "S_IFDIR", type: "constant", info: "Tipo de archivo directorio" },
  { label: "S_IFREG", type: "constant", info: "Tipo de archivo regular" },
  { label: "S_IFMT", type: "constant", info: "Máscara de tipo de archivo" },
  { label: "S_IEXEC", type: "constant", info: "Permiso de ejecución" },
  { label: "S_IWRITE", type: "constant", info: "Permiso de escritura" },
  { label: "S_IREAD", type: "constant", info: "Permiso de lectura" },
  { label: "S_IRWXU", type: "constant", info: "Permisos de usuario: lectura, escritura y ejecución" },
  { label: "S_IXUSR", type: "constant", info: "Permiso de ejecución para el usuario" },
  { label: "S_IWUSR", type: "constant", info: "Permiso de escritura para el usuario" },
  { label: "S_IRUSR", type: "constant", info: "Permiso de lectura para el usuario" },
  { label: "F_OK", type: "constant", info: "Comprobar si un archivo existe" },
  { label: "R_OK", type: "constant", info: "Comprobar si un archivo es legible" },
  { label: "W_OK", type: "constant", info: "Comprobar si un archivo es escribible" },
  { label: "X_OK", type: "constant", info: "Comprobar si un archivo es ejecutable" },
  { label: "STDIN_FILENO", type: "constant", info: "Descriptor de archivo para la entrada estándar" },
  { label: "STDOUT_FILENO", type: "constant", info: "Descriptor de archivo para la salida estándar" },
  { label: "STDERR_FILENO", type: "constant", info: "Descriptor de archivo para la salida de error estándar" }
];

const rustSupportMacros: Completion[] = [
  { label: "format!", type: "macro", info: "Crea una cadena de texto con formato" },
  { label: "print!", type: "macro", info: "Imprime texto en la salida estándar sin salto de línea" },
  { label: "println!", type: "macro", info: "Imprime texto en la salida estándar con salto de línea" },
  { label: "panic!", type: "macro", info: "Provoca un pánico en tiempo de ejecución con un mensaje" },
  { label: "format_args!", type: "macro", info: "Construye argumentos de formato para otros macros" },
  { label: "unreachable!", type: "macro", info: "Indica que un código es inalcanzable" },
  { label: "write!", type: "macro", info: "Escribe texto en un destino con formato" },
  { label: "writeln!", type: "macro", info: "Escribe texto en un destino con formato y salto de línea" }
];

const rustOperators: Completion[] = [
  { label: "!", type: "operator", info: "Operador lógico NOT" },
  { label: "!=", type: "operator", info: "Operador de desigualdad" },
  { label: "%", type: "operator", info: "Operador de módulo" },
  { label: "%=", type: "operator", info: "Asignación con módulo" },
  { label: "&", type: "operator", info: "Operador AND a nivel de bits" },
  { label: "&=", type: "operator", info: "Asignación con AND a nivel de bits" },
  { label: "&&", type: "operator", info: "Operador lógico AND" },
  { label: "*", type: "operator", info: "Operador de desreferencia o multiplicación" },
  { label: "*=", type: "operator", info: "Asignación con multiplicación" },
  { label: "+", type: "operator", info: "Operador de suma" },
  { label: "+=", type: "operator", info: "Asignación con suma" },
  { label: "-", type: "operator", info: "Operador de resta o negación" },
  { label: "-=", type: "operator", info: "Asignación con resta" },
  { label: "->", type: "operator", info: "Tipo de retorno de funciones" },
  { label: ".", type: "operator", info: "Acceso a miembros o métodos" },
  { label: "..", type: "operator", info: "Rango sin incluir el extremo superior" },
  { label: "...", type: "operator", info: "Rango incluyendo el extremo superior (obsoleto)" },
  { label: "/", type: "operator", info: "Operador de división" },
  { label: "/=", type: "operator", info: "Asignación con división" },
  { label: ":", type: "operator", info: "Separador de campos o tipos" },
  { label: ";", type: "operator", info: "Finalizador de sentencias" },
  { label: "<<", type: "operator", info: "Operador de desplazamiento a la izquierda" },
  { label: "<<=", type: "operator", info: "Asignación con desplazamiento a la izquierda" },
  { label: "<", type: "operator", info: "Operador menor que" },
  { label: "<=", type: "operator", info: "Operador menor o igual que" },
  { label: "=", type: "operator", info: "Asignación" },
  { label: "==", type: "operator", info: "Operador de igualdad" },
  { label: "=>", type: "operator", info: "Símbolo en brazos de coincidencia" },
  { label: ">", type: "operator", info: "Operador mayor que" },
  { label: ">=", type: "operator", info: "Operador mayor o igual que" },
  { label: ">>", type: "operator", info: "Operador de desplazamiento a la derecha" },
  { label: ">>=", type: "operator", info: "Asignación con desplazamiento a la derecha" },
  { label: "@", type: "operator", info: "Patrón de enlace en coincidencias" },
  { label: "^", type: "operator", info: "Operador XOR a nivel de bits" },
  { label: "^=", type: "operator", info: "Asignación con XOR a nivel de bits" },
  { label: "|", type: "operator", info: "Operador OR a nivel de bits" },
  { label: "|=", type: "operator", info: "Asignación con OR a nivel de bits" },
  { label: "||", type: "operator", info: "Operador lógico OR" },
  { label: "_", type: "operator", info: "Lugar reservado para ignorar valores" },
  { label: "?", type: "operator", info: "Operador de propagación de errores" },
  { label: "#", type: "operator", info: "Marcador de atributos o macros" }
];

export const rustCompletions: Completion[] = [
  ...rustKeywords,
  ...rustTypeKeywords,
  ...rustConstants,
  ...rustSupportMacros,
  //...rustSupportConstants,
  //...rustOperators
];
